/*
 * Verification
 * Verification REST API for verifying phone numbers and users. Support of FlashCall verification, PIN SMS verification and Callout verification.    **Note:** OTP CODE must be the full valid E.164 number that we called from.    ## Overview    For general information on how to use the Sinch APIs including methods, types, errors and authorization, please check the [Using REST](doc:using-rest) page.  Use the Sinch Verification Service to verify end-user's mobile phone numbers. The Sinch Verification APIs should be used in combination with the Verification SDKs for a complete end-to-end solution, though it is possible to only use the APIs. Currently, there are three verification methods supported:    - FlashCall verification - Android only  - PIN SMS verification - iOS, Android, Javascript  - Callout verification (voice call) - iOS only  - Data verification (distinguished by method = `seamless`) - iOS, Android    #### FlashCall verification    With the flashCall verification method, a user's phone number is verified by triggering a \"missed call\" towards this number. The call is intercepted by the Android SDK in the mobile app and blocked automatically.  To initiate a flashCall verification, check the [Android SDK documentation](doc:verification-android-the-verification-process#flash-call-verification). For additional security, it is recommended that you control which verification requests should proceed and which ones not, by listening in your backend for the [Verification Request Event](doc:verification-rest-verification-api#verification-request) and respond accordingly. Your backend will be notified on the result of the verification with the [Verification Result Event](doc:verification-rest-callback-api#verification-result-event).    #### PIN SMS verification    With the PIN SMS verification method, a user's phone number is verified by sending an SMS containing a PIN code to this number. In the case of iOS or Javascript, the user needs to enter the PIN manually in the app, while for Android there is an option of intercepting the SMS message delivery and capturing the PIN code automatically.  To initiate a PIN SMS verification, check the [iOS](doc:verification-ios-sms-verification), [Android](doc:verification-for-android) and [Javascript](doc:verification-for-javascript) documentation. For additional security, it is recommended that you control which verification requests should proceed and which ones not, by listening in your backend for the [Verification Request Event](doc:verification-rest-verification-api#verification-request) and respond accordingly. Your backend will be notified on the result of the verification with the [Verification Result Event](doc:verification-rest-callback-api#verification-result-event).    #### Callout verification    With the callout verification method, a user's phone number is verified by receiving a phone call and hearing a pre-recorded or text-to-speech message, advising the user to press a digit code. When the user presses the digit code in the dialpad, the verification is successful.  To initiate a callout verification, check the [iOS documentation](doc:verification-ios-callout-verification). For additional security, it is recommended that you control which verification requests should proceed and which ones not, by listening in your backend for the [Verification Request Event](doc:verification-rest-verification-api#verification-request) and respond accordingly. Your backend will be notified on the result of the verification with the [Verification Result Event](doc:verification-rest-callback-api#verification-result-event).    #### Data verification    With the data verification method, a user's phone number is verified by carrier using mobile data network. For additional security, it is recommended that you control which verification requests should proceed and which ones not, by listening in your backend for the [Verification Request Event](doc:verification-rest-verification-api#verification-request) and respond accordingly. Your backend will be notified on the result of the verification with the [Verification Result Event](doc:verification-rest-callback-api#verification-result-event).    > ðŸ“˜ For information about webhooks and the verifications events [Callbacks](/docs/verification-rest-callback-api).
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@sinch.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package com.sinch.sdk.domains.verification.adapters.api.v1;

import com.fasterxml.jackson.core.type.TypeReference;
import com.sinch.sdk.core.exceptions.ApiException;
import com.sinch.sdk.core.exceptions.ApiExceptionBuilder;
import com.sinch.sdk.core.http.AuthManager;
import com.sinch.sdk.core.http.HttpClient;
import com.sinch.sdk.core.http.HttpMapper;
import com.sinch.sdk.core.http.HttpMethod;
import com.sinch.sdk.core.http.HttpRequest;
import com.sinch.sdk.core.http.HttpResponse;
import com.sinch.sdk.core.http.HttpStatus;
import com.sinch.sdk.core.http.URLParameter;
import com.sinch.sdk.core.http.URLPathUtils;
import com.sinch.sdk.core.models.ServerConfiguration;
import com.sinch.sdk.domains.verification.models.dto.v1.InitiateVerificationResourceDto;
import com.sinch.sdk.domains.verification.models.dto.v1.InitiateVerificationResponseDto;
import com.sinch.sdk.domains.verification.models.dto.v1.VerificationReportRequestResourceDto;
import com.sinch.sdk.domains.verification.models.dto.v1.VerificationResponseDto;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.logging.Logger;

public class SendingAndReportingVerificationsApi {

  private static final Logger LOGGER =
      Logger.getLogger(SendingAndReportingVerificationsApi.class.getName());
  private HttpClient httpClient;
  private ServerConfiguration serverConfiguration;
  private Map<String, AuthManager> authManagersByOasSecuritySchemes;
  private HttpMapper mapper;

  public SendingAndReportingVerificationsApi(
      HttpClient httpClient,
      ServerConfiguration serverConfiguration,
      Map<String, AuthManager> authManagersByOasSecuritySchemes,
      HttpMapper mapper) {
    this.httpClient = httpClient;
    this.serverConfiguration = serverConfiguration;
    this.authManagersByOasSecuritySchemes = authManagersByOasSecuritySchemes;
    this.mapper = mapper;
  }

  /**
   * Verify verification code by Id Used to report OTP code.
   *
   * @param id (required)
   * @param verificationReportRequestResourceDto (required)
   * @return VerificationResponseDto
   * @throws ApiException if fails to make API call
   */
  public VerificationResponseDto reportVerificationById(
      String id, VerificationReportRequestResourceDto verificationReportRequestResourceDto)
      throws ApiException {

    LOGGER.finest(
        "[reportVerificationById]"
            + " "
            + "id: "
            + id
            + ", "
            + "verificationReportRequestResourceDto: "
            + verificationReportRequestResourceDto);

    HttpRequest httpRequest =
        reportVerificationByIdRequestBuilder(id, verificationReportRequestResourceDto);
    HttpResponse response =
        httpClient.invokeAPI(
            this.serverConfiguration, this.authManagersByOasSecuritySchemes, httpRequest);

    if (HttpStatus.isSuccessfulStatus(response.getCode())) {
      TypeReference<VerificationResponseDto> localVarReturnType =
          new TypeReference<VerificationResponseDto>() {};
      return mapper.deserialize(response, localVarReturnType);
    }
    // fallback to default errors handling:
    // all error cases definition are not required from specs: will try some "hardcoded" content
    // parsing
    throw ApiExceptionBuilder.build(
        response.getMessage(),
        response.getCode(),
        mapper.deserialize(response, new TypeReference<HashMap<String, ?>>() {}));
  }

  private HttpRequest reportVerificationByIdRequestBuilder(
      String id, VerificationReportRequestResourceDto verificationReportRequestResourceDto)
      throws ApiException {
    // verify the required parameter 'id' is set
    if (id == null) {
      throw new ApiException(
          400, "Missing the required parameter 'id' when calling reportVerificationById");
    }
    // verify the required parameter 'verificationReportRequestResourceDto' is set
    if (verificationReportRequestResourceDto == null) {
      throw new ApiException(
          400,
          "Missing the required parameter 'verificationReportRequestResourceDto' when calling"
              + " reportVerificationById");
    }

    String localVarPath =
        "/verification/v1/verifications/id/{id}"
            .replaceAll("\\{" + "id" + "\\}", URLPathUtils.encodePathSegment(id.toString()));

    List<URLParameter> localVarQueryParams = new ArrayList<>();

    Map<String, String> localVarHeaderParams = new HashMap<>();

    final Collection<String> localVarAccepts = Arrays.asList("application/json");

    final Collection<String> localVarContentTypes = Arrays.asList("application/json");

    final Collection<String> localVarAuthNames = Arrays.asList("Basic");
    final String serializedBody =
        mapper.serialize(localVarContentTypes, verificationReportRequestResourceDto);

    return new HttpRequest(
        localVarPath,
        HttpMethod.PUT,
        localVarQueryParams,
        serializedBody,
        localVarHeaderParams,
        localVarAccepts,
        localVarContentTypes,
        localVarAuthNames);
  }

  /**
   * Verify verification code by Identity Used to report OTP code.
   *
   * @param type Type of identity, e.g. &#39;number&#39;, &#39;email&#39; etc. (required)
   * @param endpoint Value of identity in format defined by its type. (required)
   * @param verificationReportRequestResourceDto (required)
   * @return VerificationResponseDto
   * @throws ApiException if fails to make API call
   */
  public VerificationResponseDto reportVerificationByIdentity(
      String type,
      String endpoint,
      VerificationReportRequestResourceDto verificationReportRequestResourceDto)
      throws ApiException {

    LOGGER.finest(
        "[reportVerificationByIdentity]"
            + " "
            + "type: "
            + type
            + ", "
            + "endpoint: "
            + endpoint
            + ", "
            + "verificationReportRequestResourceDto: "
            + verificationReportRequestResourceDto);

    HttpRequest httpRequest =
        reportVerificationByIdentityRequestBuilder(
            type, endpoint, verificationReportRequestResourceDto);
    HttpResponse response =
        httpClient.invokeAPI(
            this.serverConfiguration, this.authManagersByOasSecuritySchemes, httpRequest);

    if (HttpStatus.isSuccessfulStatus(response.getCode())) {
      TypeReference<VerificationResponseDto> localVarReturnType =
          new TypeReference<VerificationResponseDto>() {};
      return mapper.deserialize(response, localVarReturnType);
    }
    // fallback to default errors handling:
    // all error cases definition are not required from specs: will try some "hardcoded" content
    // parsing
    throw ApiExceptionBuilder.build(
        response.getMessage(),
        response.getCode(),
        mapper.deserialize(response, new TypeReference<HashMap<String, ?>>() {}));
  }

  private HttpRequest reportVerificationByIdentityRequestBuilder(
      String type,
      String endpoint,
      VerificationReportRequestResourceDto verificationReportRequestResourceDto)
      throws ApiException {
    // verify the required parameter 'type' is set
    if (type == null) {
      throw new ApiException(
          400, "Missing the required parameter 'type' when calling reportVerificationByIdentity");
    }
    // verify the required parameter 'endpoint' is set
    if (endpoint == null) {
      throw new ApiException(
          400,
          "Missing the required parameter 'endpoint' when calling reportVerificationByIdentity");
    }
    // verify the required parameter 'verificationReportRequestResourceDto' is set
    if (verificationReportRequestResourceDto == null) {
      throw new ApiException(
          400,
          "Missing the required parameter 'verificationReportRequestResourceDto' when calling"
              + " reportVerificationByIdentity");
    }

    String localVarPath =
        "/verification/v1/verifications/{type}/{endpoint}"
            .replaceAll("\\{" + "type" + "\\}", URLPathUtils.encodePathSegment(type.toString()))
            .replaceAll(
                "\\{" + "endpoint" + "\\}", URLPathUtils.encodePathSegment(endpoint.toString()));

    List<URLParameter> localVarQueryParams = new ArrayList<>();

    Map<String, String> localVarHeaderParams = new HashMap<>();

    final Collection<String> localVarAccepts = Arrays.asList("application/json");

    final Collection<String> localVarContentTypes = Arrays.asList("application/json");

    final Collection<String> localVarAuthNames = Arrays.asList("Basic");
    final String serializedBody =
        mapper.serialize(localVarContentTypes, verificationReportRequestResourceDto);

    return new HttpRequest(
        localVarPath,
        HttpMethod.PUT,
        localVarQueryParams,
        serializedBody,
        localVarHeaderParams,
        localVarAccepts,
        localVarContentTypes,
        localVarAuthNames);
  }

  /**
   * Start verification This method is used by the mobile and web Verification SDKs to start a
   * verification. It can also be used to request a verification from your backend, by making an
   * request.
   *
   * @param initiateVerificationResourceDto (required)
   * @return InitiateVerificationResponseDto
   * @throws ApiException if fails to make API call
   */
  public InitiateVerificationResponseDto startVerification(
      InitiateVerificationResourceDto initiateVerificationResourceDto) throws ApiException {

    LOGGER.finest(
        "[startVerification]"
            + " "
            + "initiateVerificationResourceDto: "
            + initiateVerificationResourceDto);

    HttpRequest httpRequest = startVerificationRequestBuilder(initiateVerificationResourceDto);
    HttpResponse response =
        httpClient.invokeAPI(
            this.serverConfiguration, this.authManagersByOasSecuritySchemes, httpRequest);

    if (HttpStatus.isSuccessfulStatus(response.getCode())) {
      TypeReference<InitiateVerificationResponseDto> localVarReturnType =
          new TypeReference<InitiateVerificationResponseDto>() {};
      return mapper.deserialize(response, localVarReturnType);
    }
    // fallback to default errors handling:
    // all error cases definition are not required from specs: will try some "hardcoded" content
    // parsing
    throw ApiExceptionBuilder.build(
        response.getMessage(),
        response.getCode(),
        mapper.deserialize(response, new TypeReference<HashMap<String, ?>>() {}));
  }

  private HttpRequest startVerificationRequestBuilder(
      InitiateVerificationResourceDto initiateVerificationResourceDto) throws ApiException {
    // verify the required parameter 'initiateVerificationResourceDto' is set
    if (initiateVerificationResourceDto == null) {
      throw new ApiException(
          400,
          "Missing the required parameter 'initiateVerificationResourceDto' when calling"
              + " startVerification");
    }

    String localVarPath = "/verification/v1/verifications";

    List<URLParameter> localVarQueryParams = new ArrayList<>();

    Map<String, String> localVarHeaderParams = new HashMap<>();

    final Collection<String> localVarAccepts = Arrays.asList("application/json");

    final Collection<String> localVarContentTypes = Arrays.asList("application/json");

    final Collection<String> localVarAuthNames = Arrays.asList("Basic");
    final String serializedBody =
        mapper.serialize(localVarContentTypes, initiateVerificationResourceDto);

    return new HttpRequest(
        localVarPath,
        HttpMethod.POST,
        localVarQueryParams,
        serializedBody,
        localVarHeaderParams,
        localVarAccepts,
        localVarContentTypes,
        localVarAuthNames);
  }
}
