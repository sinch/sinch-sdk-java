/*
 * Conversation API | Sinch
 * Send and receive messages globally over SMS, RCS, WhatsApp, Viber Business, Facebook messenger and other popular channels using the Sinch Conversation API.  The Conversation API endpoint uses built-in transcoding to give you the power of conversation across all supported channels and, if required, full control over channel specific features.
 *
 * The version of the OpenAPI document: 1.0
 * Contact: support@sinch.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package com.sinch.sdk.domains.conversation.models.dto.v1;

import com.fasterxml.jackson.annotation.JsonFilter;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;

/**
 * This is the request body for sending a message. &#x60;app_id&#x60;, &#x60;recipient&#x60;, and
 * &#x60;message&#x60; are all required fields.
 */
@JsonPropertyOrder({
  SendMessageRequestDto.JSON_PROPERTY_APP_ID,
  SendMessageRequestDto.JSON_PROPERTY_MESSAGE,
  SendMessageRequestDto.JSON_PROPERTY_RECIPIENT,
  SendMessageRequestDto.JSON_PROPERTY_CALLBACK_URL,
  SendMessageRequestDto.JSON_PROPERTY_CHANNEL_PRIORITY_ORDER,
  SendMessageRequestDto.JSON_PROPERTY_CHANNEL_PROPERTIES,
  SendMessageRequestDto.JSON_PROPERTY_MESSAGE_METADATA,
  SendMessageRequestDto.JSON_PROPERTY_CONVERSATION_METADATA,
  SendMessageRequestDto.JSON_PROPERTY_QUEUE,
  SendMessageRequestDto.JSON_PROPERTY_TTL,
  SendMessageRequestDto.JSON_PROPERTY_PROCESSING_STRATEGY,
  SendMessageRequestDto.JSON_PROPERTY_CORRELATION_ID,
  SendMessageRequestDto.JSON_PROPERTY_CONVERSATION_METADATA_UPDATE_STRATEGY
})
@JsonFilter("uninitializedFilter")
@JsonInclude(value = JsonInclude.Include.CUSTOM)
public class SendMessageRequestDto {
  public static final String JSON_PROPERTY_APP_ID = "app_id";
  private String appId;
  private boolean appIdDefined = false;

  public static final String JSON_PROPERTY_MESSAGE = "message";
  private AppMessageDto message;
  private boolean messageDefined = false;

  public static final String JSON_PROPERTY_RECIPIENT = "recipient";
  private SendMessageRequestRecipientDto recipient;
  private boolean recipientDefined = false;

  public static final String JSON_PROPERTY_CALLBACK_URL = "callback_url";
  private String callbackUrl;
  private boolean callbackUrlDefined = false;

  public static final String JSON_PROPERTY_CHANNEL_PRIORITY_ORDER = "channel_priority_order";
  private List<ConversationChannelDto> channelPriorityOrder;
  private boolean channelPriorityOrderDefined = false;

  public static final String JSON_PROPERTY_CHANNEL_PROPERTIES = "channel_properties";
  private Map<String, String> channelProperties;
  private boolean channelPropertiesDefined = false;

  public static final String JSON_PROPERTY_MESSAGE_METADATA = "message_metadata";
  private String messageMetadata;
  private boolean messageMetadataDefined = false;

  public static final String JSON_PROPERTY_CONVERSATION_METADATA = "conversation_metadata";
  private Object conversationMetadata;
  private boolean conversationMetadataDefined = false;

  public static final String JSON_PROPERTY_QUEUE = "queue";
  private MessageQueueDto queue;
  private boolean queueDefined = false;

  public static final String JSON_PROPERTY_TTL = "ttl";
  private String ttl;
  private boolean ttlDefined = false;

  public static final String JSON_PROPERTY_PROCESSING_STRATEGY = "processing_strategy";
  private String processingStrategy;
  private boolean processingStrategyDefined = false;

  public static final String JSON_PROPERTY_CORRELATION_ID = "correlation_id";
  private String correlationId;
  private boolean correlationIdDefined = false;

  public static final String JSON_PROPERTY_CONVERSATION_METADATA_UPDATE_STRATEGY =
      "conversation_metadata_update_strategy";
  private String conversationMetadataUpdateStrategy;
  private boolean conversationMetadataUpdateStrategyDefined = false;

  public SendMessageRequestDto() {}

  public SendMessageRequestDto appId(String appId) {
    this.appId = appId;
    this.appIdDefined = true;
    return this;
  }

  /**
   * The ID of the app sending the message.
   *
   * @return appId
   */
  @JsonProperty(JSON_PROPERTY_APP_ID)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public String getAppId() {
    return appId;
  }

  @JsonIgnore
  public boolean getAppIdDefined() {
    return appIdDefined;
  }

  @JsonProperty(JSON_PROPERTY_APP_ID)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setAppId(String appId) {
    this.appId = appId;
    this.appIdDefined = true;
  }

  public SendMessageRequestDto message(AppMessageDto message) {
    this.message = message;
    this.messageDefined = true;
    return this;
  }

  /**
   * Get message
   *
   * @return message
   */
  @JsonProperty(JSON_PROPERTY_MESSAGE)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public AppMessageDto getMessage() {
    return message;
  }

  @JsonIgnore
  public boolean getMessageDefined() {
    return messageDefined;
  }

  @JsonProperty(JSON_PROPERTY_MESSAGE)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setMessage(AppMessageDto message) {
    this.message = message;
    this.messageDefined = true;
  }

  public SendMessageRequestDto recipient(SendMessageRequestRecipientDto recipient) {
    this.recipient = recipient;
    this.recipientDefined = true;
    return this;
  }

  /**
   * Get recipient
   *
   * @return recipient
   */
  @JsonProperty(JSON_PROPERTY_RECIPIENT)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public SendMessageRequestRecipientDto getRecipient() {
    return recipient;
  }

  @JsonIgnore
  public boolean getRecipientDefined() {
    return recipientDefined;
  }

  @JsonProperty(JSON_PROPERTY_RECIPIENT)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setRecipient(SendMessageRequestRecipientDto recipient) {
    this.recipient = recipient;
    this.recipientDefined = true;
  }

  public SendMessageRequestDto callbackUrl(String callbackUrl) {
    this.callbackUrl = callbackUrl;
    this.callbackUrlDefined = true;
    return this;
  }

  /**
   * Overwrites the default callback url for delivery receipts for this message The REST URL should
   * be of the form: &#x60;http://host[:port]/path&#x60;
   *
   * @return callbackUrl
   */
  @JsonProperty(JSON_PROPERTY_CALLBACK_URL)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public String getCallbackUrl() {
    return callbackUrl;
  }

  @JsonIgnore
  public boolean getCallbackUrlDefined() {
    return callbackUrlDefined;
  }

  @JsonProperty(JSON_PROPERTY_CALLBACK_URL)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setCallbackUrl(String callbackUrl) {
    this.callbackUrl = callbackUrl;
    this.callbackUrlDefined = true;
  }

  public SendMessageRequestDto channelPriorityOrder(
      List<ConversationChannelDto> channelPriorityOrder) {
    this.channelPriorityOrder = channelPriorityOrder;
    this.channelPriorityOrderDefined = true;
    return this;
  }

  public SendMessageRequestDto addChannelPriorityOrderItem(
      ConversationChannelDto channelPriorityOrderItem) {
    if (this.channelPriorityOrder == null) {
      this.channelPriorityOrder = new ArrayList<>();
    }
    this.channelPriorityOrderDefined = true;
    this.channelPriorityOrder.add(channelPriorityOrderItem);
    return this;
  }

  /**
   * Explicitly define the channels and order in which they are tried when sending the message. All
   * channels provided in this field must be configured in the corresponding Conversation API app,
   * or the request will be rejected. Which channels the API will try and their priority is defined
   * by: 1. &#x60;channel_priority_order&#x60; if available. 2.
   * &#x60;recipient.identified_by.channel_identities&#x60; if available. 3. When recipient is a
   * &#x60;contact_id&#x60;: - if a conversation with the contact exists: the active channel of the
   * conversation is tried first. - the existing channels for the contact are ordered by contact
   * channel preferences if given. - lastly the existing channels for the contact are ordered by the
   * app priority.
   *
   * @return channelPriorityOrder
   */
  @JsonProperty(JSON_PROPERTY_CHANNEL_PRIORITY_ORDER)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public List<ConversationChannelDto> getChannelPriorityOrder() {
    return channelPriorityOrder;
  }

  @JsonIgnore
  public boolean getChannelPriorityOrderDefined() {
    return channelPriorityOrderDefined;
  }

  @JsonProperty(JSON_PROPERTY_CHANNEL_PRIORITY_ORDER)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setChannelPriorityOrder(List<ConversationChannelDto> channelPriorityOrder) {
    this.channelPriorityOrder = channelPriorityOrder;
    this.channelPriorityOrderDefined = true;
  }

  public SendMessageRequestDto channelProperties(Map<String, String> channelProperties) {
    this.channelProperties = channelProperties;
    this.channelPropertiesDefined = true;
    return this;
  }

  public SendMessageRequestDto putChannelPropertiesItem(String key, String channelPropertiesItem) {
    if (this.channelProperties == null) {
      this.channelProperties = new HashMap<>();
    }
    this.channelPropertiesDefined = true;
    this.channelProperties.put(key, channelPropertiesItem);
    return this;
  }

  /**
   * Channel-specific properties. The key in the map must point to a valid channel property key as
   * defined by the enum ChannelPropertyKeys. The maximum allowed property value length is 1024
   * characters.
   *
   * @return channelProperties
   */
  @JsonProperty(JSON_PROPERTY_CHANNEL_PROPERTIES)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public Map<String, String> getChannelProperties() {
    return channelProperties;
  }

  @JsonIgnore
  public boolean getChannelPropertiesDefined() {
    return channelPropertiesDefined;
  }

  @JsonProperty(JSON_PROPERTY_CHANNEL_PROPERTIES)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setChannelProperties(Map<String, String> channelProperties) {
    this.channelProperties = channelProperties;
    this.channelPropertiesDefined = true;
  }

  public SendMessageRequestDto messageMetadata(String messageMetadata) {
    this.messageMetadata = messageMetadata;
    this.messageMetadataDefined = true;
    return this;
  }

  /**
   * Metadata that should be associated with the message. Returned in the &#x60;metadata&#x60; field
   * of a [Message Delivery
   * Receipt](https://developers.sinch.com/docs/conversation/callbacks/#message-delivery-receipt).
   * Up to 1024 characters long.
   *
   * @return messageMetadata
   */
  @JsonProperty(JSON_PROPERTY_MESSAGE_METADATA)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public String getMessageMetadata() {
    return messageMetadata;
  }

  @JsonIgnore
  public boolean getMessageMetadataDefined() {
    return messageMetadataDefined;
  }

  @JsonProperty(JSON_PROPERTY_MESSAGE_METADATA)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setMessageMetadata(String messageMetadata) {
    this.messageMetadata = messageMetadata;
    this.messageMetadataDefined = true;
  }

  public SendMessageRequestDto conversationMetadata(Object conversationMetadata) {
    this.conversationMetadata = conversationMetadata;
    this.conversationMetadataDefined = true;
    return this;
  }

  /**
   * Metadata that should be associated with the conversation. This metadata will be propagated on
   * MO callbacks associated with this conversation. Up to 1024 characters long. Note that the MO
   * callback will always use the last metadata available in the conversation. Important notes: - If
   * you send a message with the &#x60;conversation_metadata&#x60; field populated, and then send
   * another message without populating the &#x60;conversation_metadata&#x60; field, the original
   * metadata will continue be propagated on the related MO callbacks. - If you send a message with
   * the &#x60;conversation_metadata&#x60; field populated, and then send another message with a
   * different value for &#x60;conversation_metadata&#x60; in the same conversation, the latest
   * metadata value overwrites the existing one. So, future MO callbacks will include the new
   * metadata. - The &#x60;conversation_metadata&#x60; only accepts json objects. Currently only
   * returned in the &#x60;message_metadata&#x60; field of an [Inbound
   * Message](/docs/conversation/callbacks/#inbound-message) callback.
   *
   * @return conversationMetadata
   */
  @JsonProperty(JSON_PROPERTY_CONVERSATION_METADATA)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public Object getConversationMetadata() {
    return conversationMetadata;
  }

  @JsonIgnore
  public boolean getConversationMetadataDefined() {
    return conversationMetadataDefined;
  }

  @JsonProperty(JSON_PROPERTY_CONVERSATION_METADATA)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setConversationMetadata(Object conversationMetadata) {
    this.conversationMetadata = conversationMetadata;
    this.conversationMetadataDefined = true;
  }

  public SendMessageRequestDto queue(MessageQueueDto queue) {
    this.queue = queue;
    this.queueDefined = true;
    return this;
  }

  /**
   * Get queue
   *
   * @return queue
   */
  @JsonProperty(JSON_PROPERTY_QUEUE)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public MessageQueueDto getQueue() {
    return queue;
  }

  @JsonIgnore
  public boolean getQueueDefined() {
    return queueDefined;
  }

  @JsonProperty(JSON_PROPERTY_QUEUE)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setQueue(MessageQueueDto queue) {
    this.queue = queue;
    this.queueDefined = true;
  }

  public SendMessageRequestDto ttl(String ttl) {
    this.ttl = ttl;
    this.ttlDefined = true;
    return this;
  }

  /**
   * The timeout allotted for sending the message, expressed in seconds. Passed to channels which
   * support it and emulated by the Conversation API for channels without ttl support but with
   * message retract/unsend functionality. Channel failover will not be performed for messages with
   * an expired TTL. The format is an integer with the suffix &#x60;s&#x60; (for seconds). Valid
   * integer range is 3 to 315,576,000,000 (inclusive). Example values include &#x60;10s&#x60; (10
   * seconds) and &#x60;86400s&#x60; (24 hours).
   *
   * @return ttl
   */
  @JsonProperty(JSON_PROPERTY_TTL)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public String getTtl() {
    return ttl;
  }

  @JsonIgnore
  public boolean getTtlDefined() {
    return ttlDefined;
  }

  @JsonProperty(JSON_PROPERTY_TTL)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setTtl(String ttl) {
    this.ttl = ttl;
    this.ttlDefined = true;
  }

  public SendMessageRequestDto processingStrategy(String processingStrategy) {
    this.processingStrategy = processingStrategy;
    this.processingStrategyDefined = true;
    return this;
  }

  /**
   * Overrides the app&#39;s [Processing Mode](../../../../../conversation/processing-modes/).
   * Default value is &#x60;DEFAULT&#x60;.
   *
   * @return processingStrategy
   */
  @JsonProperty(JSON_PROPERTY_PROCESSING_STRATEGY)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public String getProcessingStrategy() {
    return processingStrategy;
  }

  @JsonIgnore
  public boolean getProcessingStrategyDefined() {
    return processingStrategyDefined;
  }

  @JsonProperty(JSON_PROPERTY_PROCESSING_STRATEGY)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setProcessingStrategy(String processingStrategy) {
    this.processingStrategy = processingStrategy;
    this.processingStrategyDefined = true;
  }

  public SendMessageRequestDto correlationId(String correlationId) {
    this.correlationId = correlationId;
    this.correlationIdDefined = true;
    return this;
  }

  /**
   * An arbitrary identifier that will be propagated to callbacks related to this message, including
   * MO replies. Only applicable to messages sent with the &#x60;CONVERSATION&#x60; processing mode.
   * Up to 128 characters long.
   *
   * @return correlationId
   */
  @JsonProperty(JSON_PROPERTY_CORRELATION_ID)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public String getCorrelationId() {
    return correlationId;
  }

  @JsonIgnore
  public boolean getCorrelationIdDefined() {
    return correlationIdDefined;
  }

  @JsonProperty(JSON_PROPERTY_CORRELATION_ID)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setCorrelationId(String correlationId) {
    this.correlationId = correlationId;
    this.correlationIdDefined = true;
  }

  public SendMessageRequestDto conversationMetadataUpdateStrategy(
      String conversationMetadataUpdateStrategy) {
    this.conversationMetadataUpdateStrategy = conversationMetadataUpdateStrategy;
    this.conversationMetadataUpdateStrategyDefined = true;
    return this;
  }

  /**
   * Update strategy for the &#x60;conversation_metadata&#x60; field.
   *
   * @return conversationMetadataUpdateStrategy
   */
  @JsonProperty(JSON_PROPERTY_CONVERSATION_METADATA_UPDATE_STRATEGY)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public String getConversationMetadataUpdateStrategy() {
    return conversationMetadataUpdateStrategy;
  }

  @JsonIgnore
  public boolean getConversationMetadataUpdateStrategyDefined() {
    return conversationMetadataUpdateStrategyDefined;
  }

  @JsonProperty(JSON_PROPERTY_CONVERSATION_METADATA_UPDATE_STRATEGY)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setConversationMetadataUpdateStrategy(String conversationMetadataUpdateStrategy) {
    this.conversationMetadataUpdateStrategy = conversationMetadataUpdateStrategy;
    this.conversationMetadataUpdateStrategyDefined = true;
  }

  /** Return true if this SendMessageRequest object is equal to o. */
  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    SendMessageRequestDto sendMessageRequest = (SendMessageRequestDto) o;
    return Objects.equals(this.appId, sendMessageRequest.appId)
        && Objects.equals(this.message, sendMessageRequest.message)
        && Objects.equals(this.recipient, sendMessageRequest.recipient)
        && Objects.equals(this.callbackUrl, sendMessageRequest.callbackUrl)
        && Objects.equals(this.channelPriorityOrder, sendMessageRequest.channelPriorityOrder)
        && Objects.equals(this.channelProperties, sendMessageRequest.channelProperties)
        && Objects.equals(this.messageMetadata, sendMessageRequest.messageMetadata)
        && Objects.equals(this.conversationMetadata, sendMessageRequest.conversationMetadata)
        && Objects.equals(this.queue, sendMessageRequest.queue)
        && Objects.equals(this.ttl, sendMessageRequest.ttl)
        && Objects.equals(this.processingStrategy, sendMessageRequest.processingStrategy)
        && Objects.equals(this.correlationId, sendMessageRequest.correlationId)
        && Objects.equals(
            this.conversationMetadataUpdateStrategy,
            sendMessageRequest.conversationMetadataUpdateStrategy);
  }

  @Override
  public int hashCode() {
    return Objects.hash(
        appId,
        message,
        recipient,
        callbackUrl,
        channelPriorityOrder,
        channelProperties,
        messageMetadata,
        conversationMetadata,
        queue,
        ttl,
        processingStrategy,
        correlationId,
        conversationMetadataUpdateStrategy);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class SendMessageRequestDto {\n");
    sb.append("    appId: ").append(toIndentedString(appId)).append("\n");
    sb.append("    message: ").append(toIndentedString(message)).append("\n");
    sb.append("    recipient: ").append(toIndentedString(recipient)).append("\n");
    sb.append("    callbackUrl: ").append(toIndentedString(callbackUrl)).append("\n");
    sb.append("    channelPriorityOrder: ")
        .append(toIndentedString(channelPriorityOrder))
        .append("\n");
    sb.append("    channelProperties: ").append(toIndentedString(channelProperties)).append("\n");
    sb.append("    messageMetadata: ").append(toIndentedString(messageMetadata)).append("\n");
    sb.append("    conversationMetadata: ")
        .append(toIndentedString(conversationMetadata))
        .append("\n");
    sb.append("    queue: ").append(toIndentedString(queue)).append("\n");
    sb.append("    ttl: ").append(toIndentedString(ttl)).append("\n");
    sb.append("    processingStrategy: ").append(toIndentedString(processingStrategy)).append("\n");
    sb.append("    correlationId: ").append(toIndentedString(correlationId)).append("\n");
    sb.append("    conversationMetadataUpdateStrategy: ")
        .append(toIndentedString(conversationMetadataUpdateStrategy))
        .append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }
}
